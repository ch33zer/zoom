<head>
  <!--TODO: download? -->
  <script type="text/javascript">
    let canv = null;
    let canv_ctx = null;
    let offscreen = null;
    let offscreen_ctx = null;
    const WIDTH = 501;
    const HEIGHT = 501;
    const CHARS = "abcdefghijklmnopqrstuvwxyz";
    const FONT_SPEC = "'Roboto', sans-serif"
    const MAX_DEBUG = 2;
    let debug = 1;
    let i = 0;
    let viewStack = null;
    class ViewStack {
      constructor(size) {
        if (size % 2 == 0) {
          throw `Size must be odd! Found ${size}`
        }
        this.width = this.originalWidth = size
        this.height = this.originalHeight = size
        this.viewStack = []
        this.viewIndexes = []
        this.handleLevelChange = (v, d) => null
      }
      push(stack, index) {
        this.viewStack.push(stack)
        this.viewIndexes.push(index)
      }
      pop() {
        this.viewStack.pop()
        this.viewIndexes.pop()
      }
      pixels() {
        let out = []
        for (let x = 0; x < this.width; x++) {
          for (let y = 0; y < this.height; y++) {
            if (this.#at(this.#add({x:x, y:y}))) {
              out.push({x:x, y:y});
            }
          }
        }
        return out;
      }
      #at(indexes) {
        for (let i = 0; i < indexes.length; i++) {
          if (!this.viewStack[i].has(indexes[i])) {
            return false;
          }
        }
        return true;
      }
      static #saturatedAdd(a, b, x_sat, y_sat) {
        let rem = {x: 0, y: 0}
        let coords = {x: a.x + b.x, y: a.y + b.y}
        rem.x = Math.trunc(coords.x / x_sat) + (coords.x < 0 ? -1 : 0);
        coords.x %= x_sat 
        coords.x += coords.x < 0 ? x_sat : 0;
        rem.y = Math.trunc(coords.y / y_sat) + (coords.y < 0 ? -1 : 0);
        coords.y %= y_sat
        coords.y += coords.y < 0 ? y_sat : 0;
        return {rem: rem, coords: coords}
      }
      #add(delta) {
        let rem = {x: Math.trunc(delta.x), y: Math.trunc(delta.y)}
        let ret = []
        ret.length = this.viewIndexes.length
        for (var i = this.viewIndexes.length - 1; i >= 0; i--) {
          const curr = i2c(this.viewIndexes[i])
          let added = ViewStack.#saturatedAdd(curr, rem, this.originalWidth, this.originalHeight)
          rem = added.rem;
          ret[i] = c2i(added.coords)
        }
        return ret;
      }
      scale() {
        return this.originalWidth / this.width
      }
      #changeLevel(dir) {
        if (dir == 1) {
          this.width = this.originalWidth
          this.height = this.originalHeight
        } else {
          this.width = 1
          this.height = 1
        }
        this.handleLevelChange(this, dir)
      }
      zoomIn() {
        if (this.width > 1 && this.height > 1) {
          this.width -= 2
          this.height -= 2
          this.moveUnscaled({x: 1, y: 1})
        } else {
          this.#changeLevel(1)
        }
      }
      zoomOut() {
        if (this.width <this.originalWidth && this.height < this.originalHeight) {
          this.width += 2
          this.height += 2
          this.moveUnscaled({x: -1, y: -1})
        }
        else if (this.viewStack.length > 1) {
          this.#changeLevel(-1)
        }
      }
      getViewStackString() {
        let out = []
        for (let i of this.viewIndexes) {
          const c = i2c(i);
          out.push(`{x:${c.x},y:${c.y}}`)
        }
        return out.toString();
      }

      cursorMove(delta) {
        let newx = Math.trunc(delta.x / this.scale());
        let newy = Math.trunc(delta.y / this.scale());

        let newDelta = {
          x: newx == 0 ? Math.sign(delta.x) : newx,
          y: newy == 0 ? Math.sign(delta.y) : newy
        };
        this.moveUnscaled(newDelta)
      }
      move(delta) {
        this.moveUnscaled({
          x: Math.trunc(delta.x / this.scale()),
          y: Math.trunc(delta.y / this.scale())
        })
      }

      globalCoords() {
        let ret = {x: 0, y:0};
        let multiplier = 1;
        for (var i = this.viewIndexes.length - 1; i >= 0; i--, multiplier *= this.width) {
          let c = i2c(this.viewIndexes[i])
          ret.x += c.x * multiplier
          ret.y += c.y * multiplier
        }
        return ret;
      }
      moveUnscaled(delta) {
        this.viewIndexes = this.#add(delta)
      }
    }
    function write(canv, text, x, y, size) {
      canv.textBaseline = "middle"
      canv.textAlign = "center"
      canv.font = `${size}px ` + FONT_SPEC
      canv.fillText(text, x, y)
    }
    function draw(unused) {
      canv_ctx.clearRect(0, 0, WIDTH, HEIGHT)
      let scale = viewStack.scale();
      for (let loc of viewStack.pixels()) {
        // .5 because we draw in the center of the letter.
        write(canv_ctx, CHARS[(i+1) % CHARS.length], scale * (loc.x + .5), scale * (loc.y + .5), scale)
      }
      canv_ctx.beginPath()
      canv_ctx.arc(WIDTH / 2, HEIGHT / 2, 2, 0, 2 * Math.PI)
      canv_ctx.stroke()
      if (debug > 0) {
        document.getElementById("stack").innerHTML = `viewStack: {${viewStack.getViewStackString()}}`
        document.getElementById("scale").innerHTML = `scale: ${scale.toFixed(2)}`
      }
      window.requestAnimationFrame(draw)
    }
    function i2c(i) {
      return {x: i % WIDTH, y: Math.floor(i / WIDTH)}
    }
    function c2i(c) {
      return c.y * WIDTH + c.x
    }
    function findLocations() {
      offscreen_ctx.clearRect(0, 0, WIDTH, HEIGHT)
      write(offscreen_ctx, CHARS[i], WIDTH / 2, HEIGHT / 2, HEIGHT)
      let data = offscreen_ctx.getImageData(0, 0, WIDTH, HEIGHT)
      let out = new Set()
      for (let i = 0; i < WIDTH * HEIGHT; i += 1) {
        if ((data.data[4*i] | data.data[4*i+1] | data.data[4*i+2] | data.data[4*i+3]) != 0) {
          out.add(i)
        }
      }
      return out
    }
    function setPixelated(context){
      context['imageSmoothingEnabled'] = false;       /* standard */
      context['mozImageSmoothingEnabled'] = false;    /* Firefox */
      context['oImageSmoothingEnabled'] = false;      /* Opera */
      context['webkitImageSmoothingEnabled'] = false; /* Safari */
      context['msImageSmoothingEnabled'] = false;     /* IE */
    }
    function wheelHandler(e) {
      e.preventDefault();
      e.stopPropagation();
      if (e.deltaY < 0) {
        let mouseShift = {
          x: Math.trunc((e.clientX - WIDTH / 2)),
          y: Math.trunc((e.clientY - HEIGHT / 2))
        };
        viewStack.move(mouseShift);
        viewStack.zoomIn()
        viewStack.move({x: -mouseShift.x, y: -mouseShift.y})
      } else{
        viewStack.zoomOut()
      }
    }
    function mouseMoveHandler(e) {
      e.preventDefault();
      e.stopPropagation();

      if (e.buttons === 1) {
        viewStack.cursorMove({x: -e.movementX, y: -e.movementY})
      }
    }
    function keyUpHandler(e) {
      if (e.key == "h") {
        debug = (debug + 1) % MAX_DEBUG;
        let d = document.getElementById("debug")
        d.hidden = debug == 0;
        offscreen.hidden = debug == 0;
      }
    }
    function handleLevelChange(v, dir) {
      console.log("Level change", v, dir)
      if (dir == 1) {
        i = (i + 1) % CHARS.length
        locs = findLocations();
        v.push(locs, 0)
      }
      else if (dir == -1 && i > 0) {
        i = i > 0 ? i - 1 : CHARS.length - 1
        // Unnecessary, useful for debug.
        locs = findLocations();
        v.pop()
      }
    }
    function startDrawing() {
      canv = document.getElementById("canv")
      canv_ctx = canv.getContext("2d");
      setPixelated(canv_ctx);
      offscreen = document.getElementById("offscreen");
      offscreen_ctx = offscreen.getContext("2d", {willReadFrequently: true});
      setPixelated(offscreen_ctx)
      canv.width = offscreen.width = WIDTH;
      canv.height = offscreen.height = HEIGHT;
      canv.addEventListener("wheel", wheelHandler)
      canv.addEventListener("mousemove", mouseMoveHandler)
      document.addEventListener("keyup", keyUpHandler)
      let locs = findLocations();
      viewStack = new ViewStack(WIDTH);
      viewStack.push(locs, 0)
      viewStack.handleLevelChange = handleLevelChange
      window.requestAnimationFrame(draw)
    }
    window.addEventListener("load", startDrawing);

  </script>
  <style type="text/css">
    @font-face {
      font-family: 'Roboto';
      src: url(Roboto-Regular.ttf) format('truetype');
    }
    canvas {
      width: 500;
      height: 500;
    }
    #id {
    }
    #offscreen {
      visibility: visible
    }
    body {
      min-width: 500px;
      min-height: 500px;
      margin: 0px
    }
  </style>
</head>
<body>
  <canvas id="canv"></canvas>
  <canvas id="offscreen"></canvas>
  <div id="debug">
    <p>
      <code id="stack"></code>
    </p>
    <p>
      <code id="scale"></code>
    </p>
  </div>
</body>